<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Prediction Market Bonding Curves Explained — Mercury</title>
  <meta name="description" content="How bonding curves power prediction market liquidity. Understand AMMs, token pricing, and liquidity provision on Polymarket and Kalshi. Learn to build bonding-aware bots with Mercury.">
  <link rel="canonical" href="https://mercurysuite.io/guides/prediction-market-bonding.html">
  <meta property="og:type" content="article">
  <meta property="og:site_name" content="Mercury">
  <meta property="og:url" content="https://mercurysuite.io/guides/prediction-market-bonding.html">
  <meta property="og:title" content="Prediction Market Bonding Curves Explained — Mercury">
  <meta property="og:description" content="How bonding curves power prediction market liquidity. Understand AMMs, token pricing, and liquidity provision on Polymarket and Kalshi.">
  <meta property="og:image" content="https://mercurysuite.io/images/og-default.png">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="Prediction Market Bonding Curves Explained — Mercury">
  <meta name="twitter:description" content="How bonding curves power prediction market liquidity. Understand AMMs, token pricing, and liquidity provision on Polymarket and Kalshi.">
  <meta name="twitter:image" content="https://mercurysuite.io/images/og-default.png">
  <link rel="icon" type="image/svg+xml" href="/favicon.svg">
  <link rel="manifest" href="/manifest.json">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../styles/main.css">
  <link rel="stylesheet" href="../styles/pages.css">
  <link rel="stylesheet" href="../styles/guides.css">
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "FAQPage",
    "mainEntity": [
      {
        "@type": "Question",
        "name": "What is a bonding curve in crypto prediction markets?",
        "acceptedAnswer": {
          "@type": "Answer",
          "text": "A bonding curve is a smart contract that automatically prices outcome tokens based on supply. When traders buy tokens the price goes up along the curve. When they sell tokens the price goes down. This mechanism provides continuous liquidity without requiring order books or external market makers. The curve function — typically polynomial, logarithmic, or sigmoid — determines how steeply prices respond to changes in supply."
        }
      },
      {
        "@type": "Question",
        "name": "Are bonding curves better than order books for prediction markets?",
        "acceptedAnswer": {
          "@type": "Answer",
          "text": "Each model has tradeoffs. Bonding curves provide guaranteed liquidity for any market size and eliminate the need for external market makers, but they are vulnerable to front-running and collapse dynamics during sharp sentiment reversals. Order books, used by Polymarket and Kalshi, offer tighter spreads in liquid markets and better capital efficiency, but require active market makers and can suffer from liquidity droughts in smaller contracts. Mercury connects to both mechanisms, allowing traders to arbitrage between them."
        }
      },
      {
        "@type": "Question",
        "name": "Can I provide liquidity to prediction market bonding curves?",
        "acceptedAnswer": {
          "@type": "Answer",
          "text": "Yes, on platforms that use AMM bonding curves. Liquidity providers deposit funds into the bonding curve reserve pool and earn a share of trading fees generated by the curve. However, this carries impermanent loss risk — if the market moves significantly in one direction, your deposited capital may be worth less than if you had simply held it. Mercury can monitor your LP positions in real time and trigger automatic exits if unrealized losses exceed a threshold you define."
        }
      },
      {
        "@type": "Question",
        "name": "How do I build a bot that trades bonding curve markets?",
        "acceptedAnswer": {
          "@type": "Answer",
          "text": "Mercury's agentic AI generates complete trading bots from plain English descriptions. Describe your strategy — for example, 'buy when the bonding curve price is below the 24-hour average and sell when it mean-reverts' — and Mercury builds the entire node graph with triggers, conditions, execution rules, and risk management. You can also build manually using the visual drag-and-drop editor in Mercury Architect, connecting Trigger, Condition, Execution, and Risk nodes to create bonding-curve-aware strategies."
        }
      },
      {
        "@type": "Question",
        "name": "What is the difference between a bonding curve and an AMM in prediction markets?",
        "acceptedAnswer": {
          "@type": "Answer",
          "text": "A bonding curve is a specific type of automated market maker. All bonding curves are AMMs, but not all AMMs use bonding curves. A bonding curve prices tokens based on a deterministic supply-price function — buy tokens to mint them along the curve, sell tokens to burn them back. Other AMM designs, like Uniswap's constant product formula (x * y = k), use liquidity pools where two assets are balanced against each other. In prediction markets, bonding curves are often preferred because they map directly to probability pricing: each outcome token's price reflects its implied probability of resolving to $1."
        }
      }
    ]
  }
  </script>
</head>
<body>

  <!-- ─── NAVBAR ──────────────────────────────────────── -->
  <nav class="navbar">
    <div class="navbar-inner">
      <a href="../index.html" class="navbar-brand">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
          <circle cx="12" cy="12" r="3"/>
          <ellipse cx="12" cy="12" rx="10" ry="4" transform="rotate(30 12 12)"/>
          <ellipse cx="12" cy="12" rx="10" ry="4" transform="rotate(-30 12 12)"/>
        </svg>
        Mercury
      </a>
      <ul class="navbar-links">
        <li><a href="../index.html">Suite</a></li>
        <li><a href="../architect.html">Architect</a></li>
        <li><a href="../architect-app.html#charting">Charting</a></li>
        <li><a href="#">Backtest</a></li>
        <li><a href="../architect.html#pricing">Pricing</a></li>
      </ul>
      <div class="navbar-actions">
        <a href="#" class="btn" id="navProfile">Profile</a>
        <a href="#" class="btn" onclick="window.signOut && window.signOut()">Logout</a>
      </div>
      <button class="hamburger" id="hamburgerBtn" aria-label="Menu">
        <span></span><span></span><span></span>
      </button>
    </div>
  </nav>

  <div class="mobile-menu" id="mobileMenu">
    <a href="../index.html">Suite</a>
    <a href="../architect.html">Architect</a>
    <a href="../architect-app.html#charting">Charting</a>
    <a href="#">Backtest</a>
    <a href="../architect.html#pricing">Pricing</a>
    <a href="#" onclick="window.signOut && window.signOut()">Logout</a>
  </div>

  <!-- ─── PAGE HERO ─────────────────────────────────────── -->
  <section class="page-hero">
    <div class="container">
      <div class="section-label">Guide</div>
      <h1 class="page-title">Prediction Market Bonding Curves Explained</h1>
      <p class="page-subtitle">A deep dive into bonding curves, automated market makers, and liquidity mechanics that power prediction markets. Learn how token prices are determined algorithmically, why liquidity provision matters for accurate probability discovery, and how Mercury helps you build bots that exploit bonding curve dynamics across every major platform.</p>
    </div>
  </section>

  <!-- ─── WHAT IS A BONDING CURVE ────────────────────────── -->
  <section class="page-section">
    <div class="container">
      <div class="page-prose">
        <div class="page-prose-block">
          <h2 class="page-prose-heading">What is a bonding curve in prediction markets?</h2>
          <p>A bonding curve is a mathematical function encoded in a smart contract that automatically determines the price of a token based on its current supply. In prediction markets, bonding curves price outcome tokens — the YES and NO shares that traders buy and sell to express their views on whether a real-world event will happen. When more traders buy YES shares, the price rises along the curve. When they sell, the price decreases. This creates continuous, automated liquidity without requiring a traditional order book, human market makers, or external liquidity providers.</p>
          <p>The core concept is deceptively simple: price = f(supply), where f is a deterministic function — typically polynomial, logarithmic, or sigmoid. When you buy outcome tokens, you are minting new tokens from the curve. Your purchase funds flow into a reserve pool held by the smart contract, and the curve advances to a higher price point. When you sell, you burn tokens back to the curve, withdraw funds from the reserve, and the price slides back down. Every trade moves the price, and every price reflects the cumulative buying and selling pressure of all participants.</p>
          <p>Augur was one of the earliest prediction markets to use bonding curves for outcome share issuance, allowing anyone to create a market on any event and have it immediately liquid from the first trade. Since then, platforms like Solio, Prophet, and various DeFi prediction protocols have refined bonding curve designs for better capital efficiency, reduced slippage, and more accurate probability mapping. The model has become a foundational primitive in decentralized finance — wherever you need an asset to have a price without a centralized exchange, a bonding curve is often the answer.</p>
          <p>For traders, understanding bonding curves is not just academic. The shape of the curve determines how much slippage you face on large orders, how quickly prices respond to new information, and where exploitable mispricings tend to cluster. Whether you trade on bonding curve platforms directly or use Mercury to <a href="prediction-market-arbitrage-bot.html">arbitrage between bonding curve and order book markets</a>, the mechanics described in this guide are essential knowledge.</p>
        </div>
      </div>
    </div>
  </section>

  <!-- ─── BONDING CURVES VS ORDER BOOKS ──────────────────── -->
  <section class="page-section">
    <div class="container">
      <div class="page-prose">
        <div class="page-prose-block">
          <h2 class="page-prose-heading">How do bonding curves differ from order books?</h2>
          <p>Prediction markets use two fundamentally different mechanisms for matching trades and discovering prices: bonding curves (a type of automated market maker, or AMM) and central limit order books (CLOBs). Understanding their differences is critical for choosing where and how to trade. (For a detailed comparison of the two largest order-book platforms, see our guide on <a href="polymarket-vs-kalshi.html">Polymarket vs. Kalshi</a>.)</p>
          <p>Polymarket operates a Central Limit Order Book on the Polygon blockchain — a traditional bid/ask matching system similar to a stock exchange. Buyers post bids at specific prices, sellers post asks, and orders are matched when bid meets ask. This model requires active market makers to provide liquidity by continuously quoting both sides of the spread. When market makers withdraw — during volatile events or on low-interest contracts — liquidity dries up and spreads widen dramatically.</p>
          <p>Kalshi operates a regulated CLOB as a CFTC-designated contract market, with both human and algorithmic market makers providing liquidity. The experience is similar to Polymarket in terms of order matching, but within a US regulatory framework that imposes position limits and requires KYC verification.</p>
          <p>Bonding curve and AMM-based prediction markets — including early Augur, newer platforms like Solio, and various experimental DeFi protocols — take the opposite approach. Liquidity is algorithmic and always available from the first trade. There is no need for external liquidity providers to bootstrap a market. The smart contract itself is the counterparty to every trade, with the bonding curve function determining the price.</p>
          <p>Here is how the two models compare across key dimensions:</p>
          <ul class="legal-list">
            <li><strong>Liquidity source</strong> — Order books rely on external market makers posting bids and asks. Bonding curves generate endogenous liquidity from the reserve pool funded by previous purchases. Order books can have zero liquidity if no one is quoting. Bonding curves always have liquidity as long as the reserve pool has funds.</li>
            <li><strong>Price discovery</strong> — Order books discover price through competitive bidding between buyers and sellers, similar to an auction. Bonding curves discover price through a deterministic function of supply — the price is whatever the curve says it is at the current supply level. Order books tend to be more efficient in deep, liquid markets. Bonding curves tend to be more reliable in thin, nascent markets.</li>
            <li><strong>Slippage behavior</strong> — On order books, slippage depends on the depth of resting orders at each price level. A large order eats through the book and can experience significant slippage if depth is thin. On bonding curves, slippage is a direct function of the curve's shape — steeper curves mean more slippage per unit. The slippage is fully predictable and can be calculated before execution.</li>
            <li><strong>Capital efficiency</strong> — Order books are generally more capital-efficient because market makers can provide liquidity across a narrow price range. Bonding curves lock capital across the entire curve, from zero supply to maximum supply, meaning much of the reserve is never actively used. Concentrated liquidity designs (inspired by Uniswap v3) are beginning to address this, but most prediction market bonding curves still use full-range curves.</li>
            <li><strong>Best suited for</strong> — Order books excel in high-volume markets with strong market maker participation — the top 50 contracts on Polymarket, major Kalshi events, anything with deep two-sided interest. Bonding curves excel in long-tail markets — the thousands of smaller, less liquid prediction contracts where no market maker is willing to commit capital but traders still want to express views.</li>
          </ul>
          <p>Mercury connects to prediction markets regardless of their underlying mechanism. Whether a platform uses a CLOB or a bonding curve, Mercury's <a href="../architect.html">Architect</a> bot builder and execution engine route your trades with sub-20ms latency. This platform-agnostic design also enables cross-mechanism arbitrage — when the same event is priced at 62 cents on a bonding curve platform and 58 cents on Polymarket's order book, a Mercury bot can simultaneously buy on Polymarket and sell on the bonding curve market to capture the 4-cent spread.</p>
        </div>
      </div>
    </div>
  </section>

  <!-- ─── HOW BONDING CURVES PRICE TOKENS ────────────────── -->
  <section class="page-section">
    <div class="container">
      <div class="page-prose">
        <div class="page-prose-block">
          <h2 class="page-prose-heading">How does a bonding curve price outcome tokens?</h2>
          <p>The pricing function is the heart of any bonding curve prediction market. Different curve shapes produce different market behaviors — how quickly prices react to buying pressure, how slippage scales with order size, and how well the final price maps to real-world probability. Understanding the three most common curve types lets you anticipate market dynamics and identify when prices are moving faster or slower than fundamentals justify.</p>
          <p>The simplest design is a linear bonding curve, where price = k * supply, with k being a constant that sets the curve's steepness. If k = 0.01, then the first token minted costs $0.01, the 50th token costs $0.50, and the 100th token costs $1.00. The total cost to buy a batch of tokens is the area under the curve between the current supply and the new supply — essentially an integral of the price function. Linear curves are easy to understand and implement, but they have a major flaw for prediction markets: price sensitivity is uniform across the entire probability range. A move from 10% to 20% costs the same as a move from 80% to 90%, even though the latter represents a much stronger consensus shift and should require more capital to move.</p>
          <p>Logarithmic bonding curves address this by making price increase rapidly at first and then flatten as supply grows. The function is typically price = k * ln(supply + 1). Early tokens are cheap, making it easy to bootstrap a new market. As supply increases, each additional token costs slightly less relative to the previous increment, which means large purchases have less marginal price impact at high supply levels. This is useful for prediction markets where you want prices to stabilize as consensus forms — once a market reaches a strong majority view, it should take disproportionately large trades to push the price further.</p>
          <p>Sigmoid (S-shaped) bonding curves are the most sophisticated design for prediction markets. The price function follows an S-curve that moves slowly near the extremes (near 0% and 100% probability) and rapidly in the middle range (around 50%). This mimics how prediction markets actually behave: when a market is at 5% or 95%, it takes substantial new information to move the price. When a market is at 50%, even moderate buying pressure can shift the probability meaningfully. Sigmoid curves produce the most accurate probability discovery and the most natural trading experience, which is why they are increasingly adopted by newer prediction market protocols.</p>
          <p>In all three designs, the reserve pool is the mechanism that makes selling possible. When you buy tokens, your payment goes into the smart contract's reserve. When you sell, you burn your tokens and withdraw from the reserve at the current curve price. The reserve is always sufficient to buy back all outstanding tokens at or below the current price — this is guaranteed by the mathematics of the curve. However, the reserve does not guarantee you can sell at the price you bought. If you bought at a high price and others sold before you, the curve will have receded and your sell price will be lower. This is the core risk of bonding curve trading: the curve amplifies both upside and downside movements.</p>
          <p>For bot builders, the curve parameters — function type, steepness constant, current supply, and reserve size — are all readable from the smart contract. Mercury's API Data node can pull these values on-chain and use them as trigger inputs. For example, you can build a strategy that monitors the ratio of reserve size to token supply and triggers a buy when the ratio drops below a historical threshold, signaling that the market may be undervalued relative to the capital backing it.</p>
        </div>
      </div>
    </div>
  </section>

  <!-- ─── ROLE OF LIQUIDITY ──────────────────────────────── -->
  <section class="page-section">
    <div class="container">
      <div class="page-prose">
        <div class="page-prose-block">
          <h2 class="page-prose-heading">What role does liquidity play in prediction markets?</h2>
          <p>Liquidity is the lifeblood of prediction market accuracy. A prediction market's fundamental promise is that the price of an outcome token reflects the crowd's best estimate of the true probability. But this only works when traders can buy and sell freely without excessive friction. Thin liquidity means wide spreads, poor fill rates, and prices that lag behind reality — the contract does not reflect the true probability because the cost of expressing a view is too high relative to the potential edge.</p>
          <p>This creates a chicken-and-egg problem that has plagued prediction markets since their inception. New markets have no liquidity. Traders avoid markets with no liquidity because execution costs are too high. Without traders, there is no volume. Without volume, market makers have no incentive to provide liquidity. The market stays empty, the price stays stale, and the prediction market fails at its core function.</p>
          <p>Bonding curves solve this bootstrapping problem by providing what economists call endogenous liquidity — liquidity that comes from the mechanism itself, not from external providers. The moment a bonding curve prediction market is created, it is liquid. The first trader can buy tokens at the curve's starting price without waiting for a market maker to post a quote. The second trader benefits from the price signal established by the first. As more participants enter, the curve accumulates a larger reserve, which deepens the available sell-side liquidity. The market bootstraps itself.</p>
          <p>This endogenous liquidity is particularly valuable for long-tail markets — the thousands of niche prediction contracts that will never attract dedicated market makers. Will a specific bill pass committee? Will a mid-tier cryptocurrency hit a particular price target by December? Will a specific city break its temperature record this summer? These markets are too small for professional market makers to justify the capital allocation, but they are precisely the markets where prediction accuracy is most valuable and most underserved. Bonding curves make them viable.</p>
          <p>However, bonding curve liquidity comes with real tradeoffs. Impermanent loss affects anyone who provides liquidity to an AMM pool — if the market moves significantly in one direction, your position may be worth less than if you had simply held the underlying assets. Front-running is a persistent vulnerability: because buy and sell transactions are visible in the mempool before confirmation, MEV (maximal extractable value) bots can sandwich your trades by buying before you and selling after, extracting value at your expense. And collapse risk is acute: bonding curves amplify panic selling because each sell pushes the price down, which triggers more selling, which pushes the price down further, creating a feedback loop that can drain the reserve rapidly.</p>
          <p>For Mercury users, understanding these liquidity dynamics opens specific trading opportunities. Monitor <a href="prediction-market-arbitrage-bot.html">cross-platform price discrepancies</a> that arise when bonding curve markets and order book markets price the same event differently. Track reserve pool sizes as a leading indicator of market health. Use Mercury's agentic AI to build bots that buy into collapse dynamics when the selloff overshoots fundamentals — a bonding curve that crashes from 60 cents to 25 cents on panic selling, while polling data still supports a 55% probability, represents a quantifiable edge.</p>
        </div>
      </div>
    </div>
  </section>

  <!-- ─── TRADING WITH MERCURY ───────────────────────────── -->
  <section class="page-section">
    <div class="container">
      <div class="page-prose">
        <div class="page-prose-block">
          <h2 class="page-prose-heading">How do you trade around bonding curves with Mercury?</h2>
          <p>Mercury connects to prediction markets regardless of their underlying mechanism — CLOB or AMM, on-chain or regulated exchange. For bonding curve markets specifically, the platform's data infrastructure and bot-building tools open several strategies that are difficult or impossible to execute manually.</p>
          <p>The first and most accessible strategy is monitoring curve steepness to identify when prices are moving faster than fundamentals justify. Every bonding curve has a derivative — the rate at which price changes per unit of supply. When the derivative spikes — meaning the price is accelerating upward or downward faster than the historical norm — it often signals emotional overreaction rather than new information. Mercury's API Data node can pull on-chain curve parameters (reserve size, token supply, curve steepness constant) in real time and use them as trigger inputs for mean-reversion strategies.</p>
          <p>Mercury's agentic AI makes building these strategies fast. Describe what you want in plain English — "build a bot that buys outcome tokens when the bonding curve price is 10% below the polling average and sells when it converges" — and Mercury generates the complete node graph with triggers, conditions, execution logic, and risk management. The AI agent selects the right data sources, configures polling intervals, sets appropriate position sizing, and wires in stop-loss protection. You review the graph, adjust any parameters, and deploy. The entire process takes minutes, not days of coding.</p>
          <p>Minting and burning volume is a powerful leading indicator that most traders overlook. On bonding curve platforms, every buy mints new tokens and every sell burns them. Tracking the net mint rate — minting volume minus burning volume — reveals conviction in real time. Heavy minting on one side of a binary market signals that capital is flowing in with directional intent. If YES tokens are being minted at three times the 7-day average rate while NO minting is flat, that asymmetry often foreshadows a sustained price move. Mercury can track these on-chain metrics and trigger trades based on mint-rate thresholds.</p>
          <p>For advanced users, cross-mechanism arbitrage is one of the most consistent edges in prediction markets. When the same event is traded on both a bonding curve platform and an order book platform like Polymarket, temporary price discrepancies arise constantly. A bonding curve market might price "Will the Fed cut rates in March?" at 42 cents while Polymarket prices the same event at 38 cents. A Mercury bot can simultaneously buy on Polymarket and sell (or short) on the bonding curve platform to capture the 4-cent spread. Because bonding curve prices are deterministic and on-chain, the execution risk is lower than inter-exchange arbitrage in traditional markets. Mercury's sub-20ms execution latency ensures you capture spreads before they close. (For a full treatment of this strategy, see our guide on <a href="prediction-market-arbitrage-bot.html">prediction market arbitrage bots</a>.)</p>
          <p>Finally, Mercury's API Data node lets you pull raw bonding curve state data — reserve pool balance, total token supply, curve function parameters, recent mint and burn transactions — and feed it directly into your strategy as a trigger or condition input. This means you can build strategies that respond to structural changes in the curve itself, not just the price. For example: "If the reserve pool drops below 80% of its 30-day average while the token supply remains constant, buy — because the market is being drained of liquidity without corresponding selling, suggesting an imminent supply squeeze."</p>
        </div>
      </div>
    </div>
  </section>

  <!-- ─── MID-ARTICLE CTA ─────────────────────────────── -->
  <section class="final-cta">
    <div class="container">
      <h2 class="final-headline">Build your first bonding curve bot free.</h2>
      <p class="final-sub">Describe your strategy in plain English. Mercury's AI builds the complete node graph — triggers, conditions, execution, and risk — in seconds. Paper trade with real market data.</p>
      <div class="final-ctas">
        <a href="../signup.html" class="btn btn-primary">Start Building Free</a>
        <a href="../architect.html" class="btn">Open Architect</a>
      </div>
    </div>
  </section>

  <!-- ─── RISKS ──────────────────────────────────────────── -->
  <section class="page-section">
    <div class="container">
      <div class="page-prose">
        <div class="page-prose-block">
          <h2 class="page-prose-heading">What are the risks of bonding curve prediction markets?</h2>
          <p>Bonding curves eliminate some risks of traditional markets (no counterparty risk from market makers, no liquidity droughts from provider withdrawal) but introduce their own set of vulnerabilities. Any trader operating in bonding curve prediction markets — or building bots with <a href="prediction-market-bot-builder.html">Mercury's strategy builder</a> — should understand these risks before committing capital.</p>
          <ul class="legal-list">
            <li><strong>Front-running and MEV extraction</strong> — Because bonding curve buy and sell functions are public smart contract calls, pending transactions are visible in the blockchain mempool before they are confirmed. MEV (maximal extractable value) bots exploit this by sandwiching your trade: they buy before your transaction to push the price up, let your transaction execute at the higher price, and then sell immediately after to pocket the difference. On high-gas-fee chains, the MEV cost can exceed 2-5% of your trade value. Some platforms mitigate this with commit-reveal schemes, private mempools, or batch auctions, but the risk remains significant on most bonding curve implementations.</li>
            <li><strong>Flash loan attacks</strong> — An attacker borrows a large amount of capital within a single blockchain transaction (a flash loan), uses it to massively distort the bonding curve price, profits from the distortion through a secondary position, and repays the loan — all within a single block. This requires no upfront capital and can drain value from the reserve pool or from other traders' positions. Flash loan attacks have been documented on multiple DeFi protocols and remain a structural vulnerability of on-chain bonding curves.</li>
            <li><strong>Collapse dynamics and reflexive selling</strong> — Bonding curves amplify panic. When sellers burn tokens, the price drops. The price drop triggers more selling from traders hitting stop-losses or panicking, which burns more tokens and drops the price further. Unlike order books, where market makers can step in and absorb selling pressure at a discount, bonding curves have no circuit breakers. The sell pressure feeds directly into the curve, and the reserve drains proportionally. Markets that took weeks to build can collapse to near-zero in minutes. This reflexivity is the single greatest risk of bonding curve prediction markets.</li>
            <li><strong>Impermanent loss for liquidity providers</strong> — If you provide liquidity to an AMM prediction market pool, you face impermanent loss when the market moves significantly in one direction. As the probability shifts from 50% toward 0% or 100%, the value of your LP position diverges from what you would have earned by simply holding the outcome tokens. In prediction markets, where outcomes are binary and eventual settlement is guaranteed, impermanent loss can be permanent — the market resolves, and your LP position is worth less than your initial deposit. Mercury can help you monitor LP positions and trigger exits before losses exceed your defined threshold.</li>
            <li><strong>Oracle dependency and settlement risk</strong> — A bonding curve only handles pricing mechanics. It does not determine whether an event actually happened. That responsibility falls to an oracle — a system that feeds real-world outcome data to the smart contract for settlement. If the oracle is compromised, delayed, or makes an incorrect determination, the bonding curve settles at the wrong value and traders lose money through no fault of their own. Oracle security varies dramatically across platforms, from decentralized dispute systems (Augur's resolution process) to centralized admin keys (a single entity decides the outcome). Always evaluate the oracle mechanism before trading on any bonding curve platform.</li>
            <li><strong>Smart contract risk</strong> — The bonding curve, the reserve pool, and the settlement logic all live in smart contract code. Bugs in the curve implementation can create exploitable price anomalies, allow unauthorized withdrawals from the reserve, or prevent legitimate settlement. Even audited contracts carry residual risk. The history of DeFi is littered with exploits on contracts that passed multiple audits. Never allocate capital you cannot afford to lose to any single bonding curve platform, and diversify across multiple protocols and mechanisms.</li>
          </ul>
          <p>Mercury's risk management infrastructure helps mitigate several of these risks. Every bot built in <a href="../architect.html">Architect</a> includes mandatory Risk nodes with configurable stop-losses, maximum exposure limits, and portfolio-level kill switches. For bonding curve strategies specifically, you can configure Mercury to monitor reserve pool health and exit positions automatically if the reserve drops below a safety threshold — an early warning indicator of collapse dynamics or potential exploit.</p>
        </div>
      </div>
    </div>
  </section>

  <!-- ─── FAQ ───────────────────────────────────────────── -->
  <section class="faq-section" id="faq">
    <div class="container">
      <div class="section-label">FAQ</div>
      <h2 class="faq-headline">Frequently Asked Questions</h2>

      <div class="faq-grid">
        <details class="faq-item" open>
          <summary class="faq-question">What is a bonding curve in crypto prediction markets?</summary>
          <div class="faq-answer">A bonding curve is a smart contract that automatically prices outcome tokens based on supply. When traders buy tokens the price goes up along the curve. When they sell tokens the price goes down. This mechanism provides continuous liquidity without requiring order books or external market makers. The curve function — typically polynomial, logarithmic, or sigmoid — determines how steeply prices respond to changes in supply.</div>
        </details>

        <details class="faq-item">
          <summary class="faq-question">Are bonding curves better than order books for prediction markets?</summary>
          <div class="faq-answer">Each model has tradeoffs. Bonding curves provide guaranteed liquidity for any market size and eliminate the need for external market makers, but they are vulnerable to front-running and collapse dynamics during sharp sentiment reversals. Order books, used by Polymarket and Kalshi, offer tighter spreads in liquid markets and better capital efficiency, but require active market makers and can suffer from liquidity droughts in smaller contracts. Mercury connects to both mechanisms, allowing traders to arbitrage between them.</div>
        </details>

        <details class="faq-item">
          <summary class="faq-question">Can I provide liquidity to prediction market bonding curves?</summary>
          <div class="faq-answer">Yes, on platforms that use AMM bonding curves. Liquidity providers deposit funds into the bonding curve reserve pool and earn a share of trading fees generated by the curve. However, this carries impermanent loss risk — if the market moves significantly in one direction, your deposited capital may be worth less than if you had simply held it. Mercury can monitor your LP positions in real time and trigger automatic exits if unrealized losses exceed a threshold you define.</div>
        </details>

        <details class="faq-item">
          <summary class="faq-question">How do I build a bot that trades bonding curve markets?</summary>
          <div class="faq-answer">Mercury's agentic AI generates complete trading bots from plain English descriptions. Describe your strategy — for example, "buy when the bonding curve price is below the 24-hour average and sell when it mean-reverts" — and Mercury builds the entire node graph with triggers, conditions, execution rules, and risk management. You can also build manually using the visual drag-and-drop editor in Mercury Architect, connecting Trigger, Condition, Execution, and Risk nodes to create bonding-curve-aware strategies.</div>
        </details>

        <details class="faq-item">
          <summary class="faq-question">What is the difference between a bonding curve and an AMM in prediction markets?</summary>
          <div class="faq-answer">A bonding curve is a specific type of automated market maker. All bonding curves are AMMs, but not all AMMs use bonding curves. A bonding curve prices tokens based on a deterministic supply-price function — buy tokens to mint them along the curve, sell tokens to burn them back. Other AMM designs, like Uniswap's constant product formula (x * y = k), use liquidity pools where two assets are balanced against each other. In prediction markets, bonding curves are often preferred because they map directly to probability pricing: each outcome token's price reflects its implied probability of resolving to $1.</div>
        </details>
      </div>
    </div>
  </section>

  <!-- ─── RELATED GUIDES ─────────────────────────────────── -->
  <section class="page-section">
    <div class="container">
      <div class="page-prose">
        <div class="page-prose-block">
          <h2 class="page-prose-heading">Continue learning</h2>
          <p>This guide covers the mechanics of bonding curves and their role in prediction market liquidity. To put this knowledge into practice, explore the related guides below — each one walks through a specific strategy or platform in full detail.</p>
          <ul class="legal-list">
            <li><strong><a href="build-polymarket-bot.html">How to Build a Polymarket Trading Bot</a></strong> — step-by-step guide to building, testing, and deploying automated trading bots on Polymarket's order book using Mercury Architect.</li>
            <li><strong><a href="build-kalshi-bot.html">How to Build a Kalshi Trading Bot</a></strong> — the same walkthrough for Kalshi's regulated CLOB, including compliance considerations and execution routing.</li>
            <li><strong><a href="prediction-market-bot-builder.html">Prediction Market Bot Builder</a></strong> — a comprehensive overview of Mercury's visual bot builder, the four node types, agentic AI generation, and deployment workflow.</li>
            <li><strong><a href="prediction-market-arbitrage-bot.html">Prediction Market Arbitrage Bot</a></strong> — how to build bots that capture price discrepancies between platforms, including cross-mechanism arbitrage between bonding curve and order book markets.</li>
            <li><strong><a href="polymarket-vs-kalshi.html">Polymarket vs. Kalshi</a></strong> — a detailed feature comparison of the two largest prediction market platforms, covering fees, liquidity, contract types, and regulatory status.</li>
          </ul>
          <p>Traders who demonstrate consistent profitability on Mercury can apply for <a href="../funding.html">Mercury Funding</a> — up to $5,000 in trading capital with an 80-85% profit share. Build your track record with paper trading, graduate to live execution, and scale with Mercury's capital.</p>
        </div>
      </div>
    </div>
  </section>

  <!-- ─── FINAL CTA ─────────────────────────────────────── -->
  <section class="final-cta">
    <div class="container">
      <h2 class="final-headline">Build bonding-aware prediction market bots.</h2>
      <p class="final-sub">Free paper trading. Visual strategy builder. Sub-20ms execution. No code required.</p>
      <div class="final-ctas">
        <a href="../signup.html" class="btn btn-primary">Get Started Free</a>
        <a href="../architect.html" class="btn">Open Architect</a>
      </div>
    </div>
  </section>

  <!-- ─── FOOTER ──────────────────────────────────────── -->
  <footer class="footer">
    <div class="container">
      <div class="footer-grid">
        <div>
          <div class="footer-brand">Mercury</div>
          <p class="footer-desc">Liquid intelligence &amp; infrastructure for the next generation of traders.</p>
        </div>
        <div>
          <div class="footer-col-title">Product</div>
          <ul class="footer-links">
            <li><a href="../index.html#analytics">Analytics</a></li>
            <li><a href="../architect.html">Architect</a></li>
            <li><a href="../architect.html#pricing">Pricing</a></li>
            <li><a href="../api.html">API</a></li>
            <li><a href="../signup.html">Sign Up Free</a></li>
          </ul>
        </div>
        <div>
          <div class="footer-col-title">Company</div>
          <ul class="footer-links">
            <li><a href="../about.html">About</a></li>
            <li><a href="../careers.html">Careers</a></li>
            <li><a href="../blog.html">Blog</a></li>
            <li><a href="../contact.html">Contact</a></li>
          </ul>
        </div>
        <div>
          <div class="footer-col-title">Legal</div>
          <ul class="footer-links">
            <li><a href="../privacy.html">Privacy</a></li>
            <li><a href="../terms.html">Terms</a></li>
            <li><a href="../disclaimer.html">Disclaimer</a></li>
          </ul>
        </div>
      </div>
      <div class="footer-bottom">
        <span>&copy; 2026 Mercury — Hg 80. All rights reserved.</span>
        <div class="footer-socials">
          <a href="#">Twitter</a>
          <a href="#">Discord</a>
          <a href="#">GitHub</a>
        </div>
      </div>
    </div>
  </footer>

  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script src="../scripts/auth.js"></script>
  <script src="../scripts/nav-auth.js"></script>
  <script src="../scripts/page-transition.js"></script>
  <script>
    document.getElementById('hamburgerBtn')?.addEventListener('click', () => {
      document.getElementById('mobileMenu').classList.toggle('open');
    });
  </script>
  <script src="../scripts/ambient.js"></script>
</body>
</html>